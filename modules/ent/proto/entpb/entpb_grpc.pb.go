// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package entpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AccountServiceClient is the client API for AccountService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AccountServiceClient interface {
	Create(ctx context.Context, in *CreateAccountRequest, opts ...grpc.CallOption) (*Account, error)
	Get(ctx context.Context, in *GetAccountRequest, opts ...grpc.CallOption) (*Account, error)
	Update(ctx context.Context, in *UpdateAccountRequest, opts ...grpc.CallOption) (*Account, error)
	Delete(ctx context.Context, in *DeleteAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	List(ctx context.Context, in *ListAccountRequest, opts ...grpc.CallOption) (*ListAccountResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreateAccountsRequest, opts ...grpc.CallOption) (*BatchCreateAccountsResponse, error)
}

type accountServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAccountServiceClient(cc grpc.ClientConnInterface) AccountServiceClient {
	return &accountServiceClient{cc}
}

func (c *accountServiceClient) Create(ctx context.Context, in *CreateAccountRequest, opts ...grpc.CallOption) (*Account, error) {
	out := new(Account)
	err := c.cc.Invoke(ctx, "/entpb.AccountService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) Get(ctx context.Context, in *GetAccountRequest, opts ...grpc.CallOption) (*Account, error) {
	out := new(Account)
	err := c.cc.Invoke(ctx, "/entpb.AccountService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) Update(ctx context.Context, in *UpdateAccountRequest, opts ...grpc.CallOption) (*Account, error) {
	out := new(Account)
	err := c.cc.Invoke(ctx, "/entpb.AccountService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) Delete(ctx context.Context, in *DeleteAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/entpb.AccountService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) List(ctx context.Context, in *ListAccountRequest, opts ...grpc.CallOption) (*ListAccountResponse, error) {
	out := new(ListAccountResponse)
	err := c.cc.Invoke(ctx, "/entpb.AccountService/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) BatchCreate(ctx context.Context, in *BatchCreateAccountsRequest, opts ...grpc.CallOption) (*BatchCreateAccountsResponse, error) {
	out := new(BatchCreateAccountsResponse)
	err := c.cc.Invoke(ctx, "/entpb.AccountService/BatchCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccountServiceServer is the server API for AccountService service.
// All implementations must embed UnimplementedAccountServiceServer
// for forward compatibility
type AccountServiceServer interface {
	Create(context.Context, *CreateAccountRequest) (*Account, error)
	Get(context.Context, *GetAccountRequest) (*Account, error)
	Update(context.Context, *UpdateAccountRequest) (*Account, error)
	Delete(context.Context, *DeleteAccountRequest) (*emptypb.Empty, error)
	List(context.Context, *ListAccountRequest) (*ListAccountResponse, error)
	BatchCreate(context.Context, *BatchCreateAccountsRequest) (*BatchCreateAccountsResponse, error)
	mustEmbedUnimplementedAccountServiceServer()
}

// UnimplementedAccountServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAccountServiceServer struct {
}

func (UnimplementedAccountServiceServer) Create(context.Context, *CreateAccountRequest) (*Account, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedAccountServiceServer) Get(context.Context, *GetAccountRequest) (*Account, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedAccountServiceServer) Update(context.Context, *UpdateAccountRequest) (*Account, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedAccountServiceServer) Delete(context.Context, *DeleteAccountRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedAccountServiceServer) List(context.Context, *ListAccountRequest) (*ListAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedAccountServiceServer) BatchCreate(context.Context, *BatchCreateAccountsRequest) (*BatchCreateAccountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedAccountServiceServer) mustEmbedUnimplementedAccountServiceServer() {}

// UnsafeAccountServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AccountServiceServer will
// result in compilation errors.
type UnsafeAccountServiceServer interface {
	mustEmbedUnimplementedAccountServiceServer()
}

func RegisterAccountServiceServer(s grpc.ServiceRegistrar, srv AccountServiceServer) {
	s.RegisterService(&AccountService_ServiceDesc, srv)
}

func _AccountService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.AccountService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServiceServer).Create(ctx, req.(*CreateAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.AccountService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServiceServer).Get(ctx, req.(*GetAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.AccountService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServiceServer).Update(ctx, req.(*UpdateAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.AccountService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServiceServer).Delete(ctx, req.(*DeleteAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.AccountService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServiceServer).List(ctx, req.(*ListAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.AccountService/BatchCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServiceServer).BatchCreate(ctx, req.(*BatchCreateAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AccountService_ServiceDesc is the grpc.ServiceDesc for AccountService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AccountService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.AccountService",
	HandlerType: (*AccountServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _AccountService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _AccountService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _AccountService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _AccountService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _AccountService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _AccountService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}

// AccountFieldServiceClient is the client API for AccountFieldService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AccountFieldServiceClient interface {
	Create(ctx context.Context, in *CreateAccountFieldRequest, opts ...grpc.CallOption) (*AccountField, error)
	Get(ctx context.Context, in *GetAccountFieldRequest, opts ...grpc.CallOption) (*AccountField, error)
	Update(ctx context.Context, in *UpdateAccountFieldRequest, opts ...grpc.CallOption) (*AccountField, error)
	Delete(ctx context.Context, in *DeleteAccountFieldRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	List(ctx context.Context, in *ListAccountFieldRequest, opts ...grpc.CallOption) (*ListAccountFieldResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreateAccountFieldsRequest, opts ...grpc.CallOption) (*BatchCreateAccountFieldsResponse, error)
}

type accountFieldServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAccountFieldServiceClient(cc grpc.ClientConnInterface) AccountFieldServiceClient {
	return &accountFieldServiceClient{cc}
}

func (c *accountFieldServiceClient) Create(ctx context.Context, in *CreateAccountFieldRequest, opts ...grpc.CallOption) (*AccountField, error) {
	out := new(AccountField)
	err := c.cc.Invoke(ctx, "/entpb.AccountFieldService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountFieldServiceClient) Get(ctx context.Context, in *GetAccountFieldRequest, opts ...grpc.CallOption) (*AccountField, error) {
	out := new(AccountField)
	err := c.cc.Invoke(ctx, "/entpb.AccountFieldService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountFieldServiceClient) Update(ctx context.Context, in *UpdateAccountFieldRequest, opts ...grpc.CallOption) (*AccountField, error) {
	out := new(AccountField)
	err := c.cc.Invoke(ctx, "/entpb.AccountFieldService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountFieldServiceClient) Delete(ctx context.Context, in *DeleteAccountFieldRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/entpb.AccountFieldService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountFieldServiceClient) List(ctx context.Context, in *ListAccountFieldRequest, opts ...grpc.CallOption) (*ListAccountFieldResponse, error) {
	out := new(ListAccountFieldResponse)
	err := c.cc.Invoke(ctx, "/entpb.AccountFieldService/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountFieldServiceClient) BatchCreate(ctx context.Context, in *BatchCreateAccountFieldsRequest, opts ...grpc.CallOption) (*BatchCreateAccountFieldsResponse, error) {
	out := new(BatchCreateAccountFieldsResponse)
	err := c.cc.Invoke(ctx, "/entpb.AccountFieldService/BatchCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccountFieldServiceServer is the server API for AccountFieldService service.
// All implementations must embed UnimplementedAccountFieldServiceServer
// for forward compatibility
type AccountFieldServiceServer interface {
	Create(context.Context, *CreateAccountFieldRequest) (*AccountField, error)
	Get(context.Context, *GetAccountFieldRequest) (*AccountField, error)
	Update(context.Context, *UpdateAccountFieldRequest) (*AccountField, error)
	Delete(context.Context, *DeleteAccountFieldRequest) (*emptypb.Empty, error)
	List(context.Context, *ListAccountFieldRequest) (*ListAccountFieldResponse, error)
	BatchCreate(context.Context, *BatchCreateAccountFieldsRequest) (*BatchCreateAccountFieldsResponse, error)
	mustEmbedUnimplementedAccountFieldServiceServer()
}

// UnimplementedAccountFieldServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAccountFieldServiceServer struct {
}

func (UnimplementedAccountFieldServiceServer) Create(context.Context, *CreateAccountFieldRequest) (*AccountField, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedAccountFieldServiceServer) Get(context.Context, *GetAccountFieldRequest) (*AccountField, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedAccountFieldServiceServer) Update(context.Context, *UpdateAccountFieldRequest) (*AccountField, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedAccountFieldServiceServer) Delete(context.Context, *DeleteAccountFieldRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedAccountFieldServiceServer) List(context.Context, *ListAccountFieldRequest) (*ListAccountFieldResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedAccountFieldServiceServer) BatchCreate(context.Context, *BatchCreateAccountFieldsRequest) (*BatchCreateAccountFieldsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedAccountFieldServiceServer) mustEmbedUnimplementedAccountFieldServiceServer() {}

// UnsafeAccountFieldServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AccountFieldServiceServer will
// result in compilation errors.
type UnsafeAccountFieldServiceServer interface {
	mustEmbedUnimplementedAccountFieldServiceServer()
}

func RegisterAccountFieldServiceServer(s grpc.ServiceRegistrar, srv AccountFieldServiceServer) {
	s.RegisterService(&AccountFieldService_ServiceDesc, srv)
}

func _AccountFieldService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAccountFieldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountFieldServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.AccountFieldService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountFieldServiceServer).Create(ctx, req.(*CreateAccountFieldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountFieldService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccountFieldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountFieldServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.AccountFieldService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountFieldServiceServer).Get(ctx, req.(*GetAccountFieldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountFieldService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAccountFieldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountFieldServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.AccountFieldService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountFieldServiceServer).Update(ctx, req.(*UpdateAccountFieldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountFieldService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAccountFieldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountFieldServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.AccountFieldService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountFieldServiceServer).Delete(ctx, req.(*DeleteAccountFieldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountFieldService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAccountFieldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountFieldServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.AccountFieldService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountFieldServiceServer).List(ctx, req.(*ListAccountFieldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountFieldService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateAccountFieldsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountFieldServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.AccountFieldService/BatchCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountFieldServiceServer).BatchCreate(ctx, req.(*BatchCreateAccountFieldsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AccountFieldService_ServiceDesc is the grpc.ServiceDesc for AccountFieldService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AccountFieldService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.AccountFieldService",
	HandlerType: (*AccountFieldServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _AccountFieldService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _AccountFieldService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _AccountFieldService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _AccountFieldService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _AccountFieldService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _AccountFieldService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}

// PortalServiceClient is the client API for PortalService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PortalServiceClient interface {
	Create(ctx context.Context, in *CreatePortalRequest, opts ...grpc.CallOption) (*Portal, error)
	Get(ctx context.Context, in *GetPortalRequest, opts ...grpc.CallOption) (*Portal, error)
	Update(ctx context.Context, in *UpdatePortalRequest, opts ...grpc.CallOption) (*Portal, error)
	Delete(ctx context.Context, in *DeletePortalRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	List(ctx context.Context, in *ListPortalRequest, opts ...grpc.CallOption) (*ListPortalResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreatePortalsRequest, opts ...grpc.CallOption) (*BatchCreatePortalsResponse, error)
}

type portalServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPortalServiceClient(cc grpc.ClientConnInterface) PortalServiceClient {
	return &portalServiceClient{cc}
}

func (c *portalServiceClient) Create(ctx context.Context, in *CreatePortalRequest, opts ...grpc.CallOption) (*Portal, error) {
	out := new(Portal)
	err := c.cc.Invoke(ctx, "/entpb.PortalService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portalServiceClient) Get(ctx context.Context, in *GetPortalRequest, opts ...grpc.CallOption) (*Portal, error) {
	out := new(Portal)
	err := c.cc.Invoke(ctx, "/entpb.PortalService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portalServiceClient) Update(ctx context.Context, in *UpdatePortalRequest, opts ...grpc.CallOption) (*Portal, error) {
	out := new(Portal)
	err := c.cc.Invoke(ctx, "/entpb.PortalService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portalServiceClient) Delete(ctx context.Context, in *DeletePortalRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/entpb.PortalService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portalServiceClient) List(ctx context.Context, in *ListPortalRequest, opts ...grpc.CallOption) (*ListPortalResponse, error) {
	out := new(ListPortalResponse)
	err := c.cc.Invoke(ctx, "/entpb.PortalService/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portalServiceClient) BatchCreate(ctx context.Context, in *BatchCreatePortalsRequest, opts ...grpc.CallOption) (*BatchCreatePortalsResponse, error) {
	out := new(BatchCreatePortalsResponse)
	err := c.cc.Invoke(ctx, "/entpb.PortalService/BatchCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PortalServiceServer is the server API for PortalService service.
// All implementations must embed UnimplementedPortalServiceServer
// for forward compatibility
type PortalServiceServer interface {
	Create(context.Context, *CreatePortalRequest) (*Portal, error)
	Get(context.Context, *GetPortalRequest) (*Portal, error)
	Update(context.Context, *UpdatePortalRequest) (*Portal, error)
	Delete(context.Context, *DeletePortalRequest) (*emptypb.Empty, error)
	List(context.Context, *ListPortalRequest) (*ListPortalResponse, error)
	BatchCreate(context.Context, *BatchCreatePortalsRequest) (*BatchCreatePortalsResponse, error)
	mustEmbedUnimplementedPortalServiceServer()
}

// UnimplementedPortalServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPortalServiceServer struct {
}

func (UnimplementedPortalServiceServer) Create(context.Context, *CreatePortalRequest) (*Portal, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedPortalServiceServer) Get(context.Context, *GetPortalRequest) (*Portal, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedPortalServiceServer) Update(context.Context, *UpdatePortalRequest) (*Portal, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedPortalServiceServer) Delete(context.Context, *DeletePortalRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedPortalServiceServer) List(context.Context, *ListPortalRequest) (*ListPortalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedPortalServiceServer) BatchCreate(context.Context, *BatchCreatePortalsRequest) (*BatchCreatePortalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedPortalServiceServer) mustEmbedUnimplementedPortalServiceServer() {}

// UnsafePortalServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PortalServiceServer will
// result in compilation errors.
type UnsafePortalServiceServer interface {
	mustEmbedUnimplementedPortalServiceServer()
}

func RegisterPortalServiceServer(s grpc.ServiceRegistrar, srv PortalServiceServer) {
	s.RegisterService(&PortalService_ServiceDesc, srv)
}

func _PortalService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePortalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortalServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.PortalService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortalServiceServer).Create(ctx, req.(*CreatePortalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortalService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPortalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortalServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.PortalService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortalServiceServer).Get(ctx, req.(*GetPortalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortalService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePortalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortalServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.PortalService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortalServiceServer).Update(ctx, req.(*UpdatePortalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortalService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePortalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortalServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.PortalService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortalServiceServer).Delete(ctx, req.(*DeletePortalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortalService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPortalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortalServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.PortalService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortalServiceServer).List(ctx, req.(*ListPortalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortalService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreatePortalsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortalServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.PortalService/BatchCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortalServiceServer).BatchCreate(ctx, req.(*BatchCreatePortalsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PortalService_ServiceDesc is the grpc.ServiceDesc for PortalService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PortalService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.PortalService",
	HandlerType: (*PortalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _PortalService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _PortalService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _PortalService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _PortalService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _PortalService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _PortalService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}

// PortalLegalServiceClient is the client API for PortalLegalService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PortalLegalServiceClient interface {
	Create(ctx context.Context, in *CreatePortalLegalRequest, opts ...grpc.CallOption) (*PortalLegal, error)
	Get(ctx context.Context, in *GetPortalLegalRequest, opts ...grpc.CallOption) (*PortalLegal, error)
	Update(ctx context.Context, in *UpdatePortalLegalRequest, opts ...grpc.CallOption) (*PortalLegal, error)
	Delete(ctx context.Context, in *DeletePortalLegalRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	List(ctx context.Context, in *ListPortalLegalRequest, opts ...grpc.CallOption) (*ListPortalLegalResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreatePortalLegalsRequest, opts ...grpc.CallOption) (*BatchCreatePortalLegalsResponse, error)
}

type portalLegalServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPortalLegalServiceClient(cc grpc.ClientConnInterface) PortalLegalServiceClient {
	return &portalLegalServiceClient{cc}
}

func (c *portalLegalServiceClient) Create(ctx context.Context, in *CreatePortalLegalRequest, opts ...grpc.CallOption) (*PortalLegal, error) {
	out := new(PortalLegal)
	err := c.cc.Invoke(ctx, "/entpb.PortalLegalService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portalLegalServiceClient) Get(ctx context.Context, in *GetPortalLegalRequest, opts ...grpc.CallOption) (*PortalLegal, error) {
	out := new(PortalLegal)
	err := c.cc.Invoke(ctx, "/entpb.PortalLegalService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portalLegalServiceClient) Update(ctx context.Context, in *UpdatePortalLegalRequest, opts ...grpc.CallOption) (*PortalLegal, error) {
	out := new(PortalLegal)
	err := c.cc.Invoke(ctx, "/entpb.PortalLegalService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portalLegalServiceClient) Delete(ctx context.Context, in *DeletePortalLegalRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/entpb.PortalLegalService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portalLegalServiceClient) List(ctx context.Context, in *ListPortalLegalRequest, opts ...grpc.CallOption) (*ListPortalLegalResponse, error) {
	out := new(ListPortalLegalResponse)
	err := c.cc.Invoke(ctx, "/entpb.PortalLegalService/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portalLegalServiceClient) BatchCreate(ctx context.Context, in *BatchCreatePortalLegalsRequest, opts ...grpc.CallOption) (*BatchCreatePortalLegalsResponse, error) {
	out := new(BatchCreatePortalLegalsResponse)
	err := c.cc.Invoke(ctx, "/entpb.PortalLegalService/BatchCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PortalLegalServiceServer is the server API for PortalLegalService service.
// All implementations must embed UnimplementedPortalLegalServiceServer
// for forward compatibility
type PortalLegalServiceServer interface {
	Create(context.Context, *CreatePortalLegalRequest) (*PortalLegal, error)
	Get(context.Context, *GetPortalLegalRequest) (*PortalLegal, error)
	Update(context.Context, *UpdatePortalLegalRequest) (*PortalLegal, error)
	Delete(context.Context, *DeletePortalLegalRequest) (*emptypb.Empty, error)
	List(context.Context, *ListPortalLegalRequest) (*ListPortalLegalResponse, error)
	BatchCreate(context.Context, *BatchCreatePortalLegalsRequest) (*BatchCreatePortalLegalsResponse, error)
	mustEmbedUnimplementedPortalLegalServiceServer()
}

// UnimplementedPortalLegalServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPortalLegalServiceServer struct {
}

func (UnimplementedPortalLegalServiceServer) Create(context.Context, *CreatePortalLegalRequest) (*PortalLegal, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedPortalLegalServiceServer) Get(context.Context, *GetPortalLegalRequest) (*PortalLegal, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedPortalLegalServiceServer) Update(context.Context, *UpdatePortalLegalRequest) (*PortalLegal, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedPortalLegalServiceServer) Delete(context.Context, *DeletePortalLegalRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedPortalLegalServiceServer) List(context.Context, *ListPortalLegalRequest) (*ListPortalLegalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedPortalLegalServiceServer) BatchCreate(context.Context, *BatchCreatePortalLegalsRequest) (*BatchCreatePortalLegalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedPortalLegalServiceServer) mustEmbedUnimplementedPortalLegalServiceServer() {}

// UnsafePortalLegalServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PortalLegalServiceServer will
// result in compilation errors.
type UnsafePortalLegalServiceServer interface {
	mustEmbedUnimplementedPortalLegalServiceServer()
}

func RegisterPortalLegalServiceServer(s grpc.ServiceRegistrar, srv PortalLegalServiceServer) {
	s.RegisterService(&PortalLegalService_ServiceDesc, srv)
}

func _PortalLegalService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePortalLegalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortalLegalServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.PortalLegalService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortalLegalServiceServer).Create(ctx, req.(*CreatePortalLegalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortalLegalService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPortalLegalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortalLegalServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.PortalLegalService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortalLegalServiceServer).Get(ctx, req.(*GetPortalLegalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortalLegalService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePortalLegalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortalLegalServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.PortalLegalService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortalLegalServiceServer).Update(ctx, req.(*UpdatePortalLegalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortalLegalService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePortalLegalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortalLegalServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.PortalLegalService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortalLegalServiceServer).Delete(ctx, req.(*DeletePortalLegalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortalLegalService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPortalLegalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortalLegalServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.PortalLegalService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortalLegalServiceServer).List(ctx, req.(*ListPortalLegalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortalLegalService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreatePortalLegalsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortalLegalServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.PortalLegalService/BatchCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortalLegalServiceServer).BatchCreate(ctx, req.(*BatchCreatePortalLegalsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PortalLegalService_ServiceDesc is the grpc.ServiceDesc for PortalLegalService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PortalLegalService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.PortalLegalService",
	HandlerType: (*PortalLegalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _PortalLegalService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _PortalLegalService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _PortalLegalService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _PortalLegalService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _PortalLegalService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _PortalLegalService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}

// PortalMetadataServiceClient is the client API for PortalMetadataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PortalMetadataServiceClient interface {
	Create(ctx context.Context, in *CreatePortalMetadataRequest, opts ...grpc.CallOption) (*PortalMetadata, error)
	Get(ctx context.Context, in *GetPortalMetadataRequest, opts ...grpc.CallOption) (*PortalMetadata, error)
	Update(ctx context.Context, in *UpdatePortalMetadataRequest, opts ...grpc.CallOption) (*PortalMetadata, error)
	Delete(ctx context.Context, in *DeletePortalMetadataRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	List(ctx context.Context, in *ListPortalMetadataRequest, opts ...grpc.CallOption) (*ListPortalMetadataResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreatePortalMetadataSliceRequest, opts ...grpc.CallOption) (*BatchCreatePortalMetadataSliceResponse, error)
}

type portalMetadataServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPortalMetadataServiceClient(cc grpc.ClientConnInterface) PortalMetadataServiceClient {
	return &portalMetadataServiceClient{cc}
}

func (c *portalMetadataServiceClient) Create(ctx context.Context, in *CreatePortalMetadataRequest, opts ...grpc.CallOption) (*PortalMetadata, error) {
	out := new(PortalMetadata)
	err := c.cc.Invoke(ctx, "/entpb.PortalMetadataService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portalMetadataServiceClient) Get(ctx context.Context, in *GetPortalMetadataRequest, opts ...grpc.CallOption) (*PortalMetadata, error) {
	out := new(PortalMetadata)
	err := c.cc.Invoke(ctx, "/entpb.PortalMetadataService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portalMetadataServiceClient) Update(ctx context.Context, in *UpdatePortalMetadataRequest, opts ...grpc.CallOption) (*PortalMetadata, error) {
	out := new(PortalMetadata)
	err := c.cc.Invoke(ctx, "/entpb.PortalMetadataService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portalMetadataServiceClient) Delete(ctx context.Context, in *DeletePortalMetadataRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/entpb.PortalMetadataService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portalMetadataServiceClient) List(ctx context.Context, in *ListPortalMetadataRequest, opts ...grpc.CallOption) (*ListPortalMetadataResponse, error) {
	out := new(ListPortalMetadataResponse)
	err := c.cc.Invoke(ctx, "/entpb.PortalMetadataService/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *portalMetadataServiceClient) BatchCreate(ctx context.Context, in *BatchCreatePortalMetadataSliceRequest, opts ...grpc.CallOption) (*BatchCreatePortalMetadataSliceResponse, error) {
	out := new(BatchCreatePortalMetadataSliceResponse)
	err := c.cc.Invoke(ctx, "/entpb.PortalMetadataService/BatchCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PortalMetadataServiceServer is the server API for PortalMetadataService service.
// All implementations must embed UnimplementedPortalMetadataServiceServer
// for forward compatibility
type PortalMetadataServiceServer interface {
	Create(context.Context, *CreatePortalMetadataRequest) (*PortalMetadata, error)
	Get(context.Context, *GetPortalMetadataRequest) (*PortalMetadata, error)
	Update(context.Context, *UpdatePortalMetadataRequest) (*PortalMetadata, error)
	Delete(context.Context, *DeletePortalMetadataRequest) (*emptypb.Empty, error)
	List(context.Context, *ListPortalMetadataRequest) (*ListPortalMetadataResponse, error)
	BatchCreate(context.Context, *BatchCreatePortalMetadataSliceRequest) (*BatchCreatePortalMetadataSliceResponse, error)
	mustEmbedUnimplementedPortalMetadataServiceServer()
}

// UnimplementedPortalMetadataServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPortalMetadataServiceServer struct {
}

func (UnimplementedPortalMetadataServiceServer) Create(context.Context, *CreatePortalMetadataRequest) (*PortalMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedPortalMetadataServiceServer) Get(context.Context, *GetPortalMetadataRequest) (*PortalMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedPortalMetadataServiceServer) Update(context.Context, *UpdatePortalMetadataRequest) (*PortalMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedPortalMetadataServiceServer) Delete(context.Context, *DeletePortalMetadataRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedPortalMetadataServiceServer) List(context.Context, *ListPortalMetadataRequest) (*ListPortalMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedPortalMetadataServiceServer) BatchCreate(context.Context, *BatchCreatePortalMetadataSliceRequest) (*BatchCreatePortalMetadataSliceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedPortalMetadataServiceServer) mustEmbedUnimplementedPortalMetadataServiceServer() {}

// UnsafePortalMetadataServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PortalMetadataServiceServer will
// result in compilation errors.
type UnsafePortalMetadataServiceServer interface {
	mustEmbedUnimplementedPortalMetadataServiceServer()
}

func RegisterPortalMetadataServiceServer(s grpc.ServiceRegistrar, srv PortalMetadataServiceServer) {
	s.RegisterService(&PortalMetadataService_ServiceDesc, srv)
}

func _PortalMetadataService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePortalMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortalMetadataServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.PortalMetadataService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortalMetadataServiceServer).Create(ctx, req.(*CreatePortalMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortalMetadataService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPortalMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortalMetadataServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.PortalMetadataService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortalMetadataServiceServer).Get(ctx, req.(*GetPortalMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortalMetadataService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePortalMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortalMetadataServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.PortalMetadataService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortalMetadataServiceServer).Update(ctx, req.(*UpdatePortalMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortalMetadataService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePortalMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortalMetadataServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.PortalMetadataService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortalMetadataServiceServer).Delete(ctx, req.(*DeletePortalMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortalMetadataService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPortalMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortalMetadataServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.PortalMetadataService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortalMetadataServiceServer).List(ctx, req.(*ListPortalMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PortalMetadataService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreatePortalMetadataSliceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PortalMetadataServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.PortalMetadataService/BatchCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PortalMetadataServiceServer).BatchCreate(ctx, req.(*BatchCreatePortalMetadataSliceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PortalMetadataService_ServiceDesc is the grpc.ServiceDesc for PortalMetadataService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PortalMetadataService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.PortalMetadataService",
	HandlerType: (*PortalMetadataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _PortalMetadataService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _PortalMetadataService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _PortalMetadataService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _PortalMetadataService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _PortalMetadataService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _PortalMetadataService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	Create(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*User, error)
	Get(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*User, error)
	Update(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*User, error)
	Delete(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	List(ctx context.Context, in *ListUserRequest, opts ...grpc.CallOption) (*ListUserResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreateUsersRequest, opts ...grpc.CallOption) (*BatchCreateUsersResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) Create(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/entpb.UserService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Get(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/entpb.UserService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Update(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/entpb.UserService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Delete(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/entpb.UserService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) List(ctx context.Context, in *ListUserRequest, opts ...grpc.CallOption) (*ListUserResponse, error) {
	out := new(ListUserResponse)
	err := c.cc.Invoke(ctx, "/entpb.UserService/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) BatchCreate(ctx context.Context, in *BatchCreateUsersRequest, opts ...grpc.CallOption) (*BatchCreateUsersResponse, error) {
	out := new(BatchCreateUsersResponse)
	err := c.cc.Invoke(ctx, "/entpb.UserService/BatchCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility
type UserServiceServer interface {
	Create(context.Context, *CreateUserRequest) (*User, error)
	Get(context.Context, *GetUserRequest) (*User, error)
	Update(context.Context, *UpdateUserRequest) (*User, error)
	Delete(context.Context, *DeleteUserRequest) (*emptypb.Empty, error)
	List(context.Context, *ListUserRequest) (*ListUserResponse, error)
	BatchCreate(context.Context, *BatchCreateUsersRequest) (*BatchCreateUsersResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserServiceServer struct {
}

func (UnimplementedUserServiceServer) Create(context.Context, *CreateUserRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedUserServiceServer) Get(context.Context, *GetUserRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedUserServiceServer) Update(context.Context, *UpdateUserRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedUserServiceServer) Delete(context.Context, *DeleteUserRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedUserServiceServer) List(context.Context, *ListUserRequest) (*ListUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedUserServiceServer) BatchCreate(context.Context, *BatchCreateUsersRequest) (*BatchCreateUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.UserService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Create(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.UserService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Get(ctx, req.(*GetUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.UserService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Update(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.UserService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Delete(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.UserService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).List(ctx, req.(*ListUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.UserService/BatchCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).BatchCreate(ctx, req.(*BatchCreateUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _UserService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _UserService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _UserService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _UserService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _UserService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _UserService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}

// UserEmailServiceClient is the client API for UserEmailService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserEmailServiceClient interface {
	Create(ctx context.Context, in *CreateUserEmailRequest, opts ...grpc.CallOption) (*UserEmail, error)
	Get(ctx context.Context, in *GetUserEmailRequest, opts ...grpc.CallOption) (*UserEmail, error)
	Update(ctx context.Context, in *UpdateUserEmailRequest, opts ...grpc.CallOption) (*UserEmail, error)
	Delete(ctx context.Context, in *DeleteUserEmailRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	List(ctx context.Context, in *ListUserEmailRequest, opts ...grpc.CallOption) (*ListUserEmailResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreateUserEmailsRequest, opts ...grpc.CallOption) (*BatchCreateUserEmailsResponse, error)
}

type userEmailServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserEmailServiceClient(cc grpc.ClientConnInterface) UserEmailServiceClient {
	return &userEmailServiceClient{cc}
}

func (c *userEmailServiceClient) Create(ctx context.Context, in *CreateUserEmailRequest, opts ...grpc.CallOption) (*UserEmail, error) {
	out := new(UserEmail)
	err := c.cc.Invoke(ctx, "/entpb.UserEmailService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userEmailServiceClient) Get(ctx context.Context, in *GetUserEmailRequest, opts ...grpc.CallOption) (*UserEmail, error) {
	out := new(UserEmail)
	err := c.cc.Invoke(ctx, "/entpb.UserEmailService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userEmailServiceClient) Update(ctx context.Context, in *UpdateUserEmailRequest, opts ...grpc.CallOption) (*UserEmail, error) {
	out := new(UserEmail)
	err := c.cc.Invoke(ctx, "/entpb.UserEmailService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userEmailServiceClient) Delete(ctx context.Context, in *DeleteUserEmailRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/entpb.UserEmailService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userEmailServiceClient) List(ctx context.Context, in *ListUserEmailRequest, opts ...grpc.CallOption) (*ListUserEmailResponse, error) {
	out := new(ListUserEmailResponse)
	err := c.cc.Invoke(ctx, "/entpb.UserEmailService/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userEmailServiceClient) BatchCreate(ctx context.Context, in *BatchCreateUserEmailsRequest, opts ...grpc.CallOption) (*BatchCreateUserEmailsResponse, error) {
	out := new(BatchCreateUserEmailsResponse)
	err := c.cc.Invoke(ctx, "/entpb.UserEmailService/BatchCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserEmailServiceServer is the server API for UserEmailService service.
// All implementations must embed UnimplementedUserEmailServiceServer
// for forward compatibility
type UserEmailServiceServer interface {
	Create(context.Context, *CreateUserEmailRequest) (*UserEmail, error)
	Get(context.Context, *GetUserEmailRequest) (*UserEmail, error)
	Update(context.Context, *UpdateUserEmailRequest) (*UserEmail, error)
	Delete(context.Context, *DeleteUserEmailRequest) (*emptypb.Empty, error)
	List(context.Context, *ListUserEmailRequest) (*ListUserEmailResponse, error)
	BatchCreate(context.Context, *BatchCreateUserEmailsRequest) (*BatchCreateUserEmailsResponse, error)
	mustEmbedUnimplementedUserEmailServiceServer()
}

// UnimplementedUserEmailServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserEmailServiceServer struct {
}

func (UnimplementedUserEmailServiceServer) Create(context.Context, *CreateUserEmailRequest) (*UserEmail, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedUserEmailServiceServer) Get(context.Context, *GetUserEmailRequest) (*UserEmail, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedUserEmailServiceServer) Update(context.Context, *UpdateUserEmailRequest) (*UserEmail, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedUserEmailServiceServer) Delete(context.Context, *DeleteUserEmailRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedUserEmailServiceServer) List(context.Context, *ListUserEmailRequest) (*ListUserEmailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedUserEmailServiceServer) BatchCreate(context.Context, *BatchCreateUserEmailsRequest) (*BatchCreateUserEmailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedUserEmailServiceServer) mustEmbedUnimplementedUserEmailServiceServer() {}

// UnsafeUserEmailServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserEmailServiceServer will
// result in compilation errors.
type UnsafeUserEmailServiceServer interface {
	mustEmbedUnimplementedUserEmailServiceServer()
}

func RegisterUserEmailServiceServer(s grpc.ServiceRegistrar, srv UserEmailServiceServer) {
	s.RegisterService(&UserEmailService_ServiceDesc, srv)
}

func _UserEmailService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEmailServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.UserEmailService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEmailServiceServer).Create(ctx, req.(*CreateUserEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserEmailService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEmailServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.UserEmailService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEmailServiceServer).Get(ctx, req.(*GetUserEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserEmailService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEmailServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.UserEmailService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEmailServiceServer).Update(ctx, req.(*UpdateUserEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserEmailService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEmailServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.UserEmailService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEmailServiceServer).Delete(ctx, req.(*DeleteUserEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserEmailService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEmailServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.UserEmailService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEmailServiceServer).List(ctx, req.(*ListUserEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserEmailService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateUserEmailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEmailServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.UserEmailService/BatchCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEmailServiceServer).BatchCreate(ctx, req.(*BatchCreateUserEmailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserEmailService_ServiceDesc is the grpc.ServiceDesc for UserEmailService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserEmailService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.UserEmailService",
	HandlerType: (*UserEmailServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _UserEmailService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _UserEmailService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _UserEmailService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _UserEmailService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _UserEmailService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _UserEmailService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}

// UserPasswordServiceClient is the client API for UserPasswordService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserPasswordServiceClient interface {
	Create(ctx context.Context, in *CreateUserPasswordRequest, opts ...grpc.CallOption) (*UserPassword, error)
	Get(ctx context.Context, in *GetUserPasswordRequest, opts ...grpc.CallOption) (*UserPassword, error)
	Update(ctx context.Context, in *UpdateUserPasswordRequest, opts ...grpc.CallOption) (*UserPassword, error)
	Delete(ctx context.Context, in *DeleteUserPasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	List(ctx context.Context, in *ListUserPasswordRequest, opts ...grpc.CallOption) (*ListUserPasswordResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreateUserPasswordsRequest, opts ...grpc.CallOption) (*BatchCreateUserPasswordsResponse, error)
}

type userPasswordServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserPasswordServiceClient(cc grpc.ClientConnInterface) UserPasswordServiceClient {
	return &userPasswordServiceClient{cc}
}

func (c *userPasswordServiceClient) Create(ctx context.Context, in *CreateUserPasswordRequest, opts ...grpc.CallOption) (*UserPassword, error) {
	out := new(UserPassword)
	err := c.cc.Invoke(ctx, "/entpb.UserPasswordService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userPasswordServiceClient) Get(ctx context.Context, in *GetUserPasswordRequest, opts ...grpc.CallOption) (*UserPassword, error) {
	out := new(UserPassword)
	err := c.cc.Invoke(ctx, "/entpb.UserPasswordService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userPasswordServiceClient) Update(ctx context.Context, in *UpdateUserPasswordRequest, opts ...grpc.CallOption) (*UserPassword, error) {
	out := new(UserPassword)
	err := c.cc.Invoke(ctx, "/entpb.UserPasswordService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userPasswordServiceClient) Delete(ctx context.Context, in *DeleteUserPasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/entpb.UserPasswordService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userPasswordServiceClient) List(ctx context.Context, in *ListUserPasswordRequest, opts ...grpc.CallOption) (*ListUserPasswordResponse, error) {
	out := new(ListUserPasswordResponse)
	err := c.cc.Invoke(ctx, "/entpb.UserPasswordService/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userPasswordServiceClient) BatchCreate(ctx context.Context, in *BatchCreateUserPasswordsRequest, opts ...grpc.CallOption) (*BatchCreateUserPasswordsResponse, error) {
	out := new(BatchCreateUserPasswordsResponse)
	err := c.cc.Invoke(ctx, "/entpb.UserPasswordService/BatchCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserPasswordServiceServer is the server API for UserPasswordService service.
// All implementations must embed UnimplementedUserPasswordServiceServer
// for forward compatibility
type UserPasswordServiceServer interface {
	Create(context.Context, *CreateUserPasswordRequest) (*UserPassword, error)
	Get(context.Context, *GetUserPasswordRequest) (*UserPassword, error)
	Update(context.Context, *UpdateUserPasswordRequest) (*UserPassword, error)
	Delete(context.Context, *DeleteUserPasswordRequest) (*emptypb.Empty, error)
	List(context.Context, *ListUserPasswordRequest) (*ListUserPasswordResponse, error)
	BatchCreate(context.Context, *BatchCreateUserPasswordsRequest) (*BatchCreateUserPasswordsResponse, error)
	mustEmbedUnimplementedUserPasswordServiceServer()
}

// UnimplementedUserPasswordServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserPasswordServiceServer struct {
}

func (UnimplementedUserPasswordServiceServer) Create(context.Context, *CreateUserPasswordRequest) (*UserPassword, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedUserPasswordServiceServer) Get(context.Context, *GetUserPasswordRequest) (*UserPassword, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedUserPasswordServiceServer) Update(context.Context, *UpdateUserPasswordRequest) (*UserPassword, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedUserPasswordServiceServer) Delete(context.Context, *DeleteUserPasswordRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedUserPasswordServiceServer) List(context.Context, *ListUserPasswordRequest) (*ListUserPasswordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedUserPasswordServiceServer) BatchCreate(context.Context, *BatchCreateUserPasswordsRequest) (*BatchCreateUserPasswordsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedUserPasswordServiceServer) mustEmbedUnimplementedUserPasswordServiceServer() {}

// UnsafeUserPasswordServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserPasswordServiceServer will
// result in compilation errors.
type UnsafeUserPasswordServiceServer interface {
	mustEmbedUnimplementedUserPasswordServiceServer()
}

func RegisterUserPasswordServiceServer(s grpc.ServiceRegistrar, srv UserPasswordServiceServer) {
	s.RegisterService(&UserPasswordService_ServiceDesc, srv)
}

func _UserPasswordService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserPasswordServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.UserPasswordService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserPasswordServiceServer).Create(ctx, req.(*CreateUserPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserPasswordService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserPasswordServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.UserPasswordService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserPasswordServiceServer).Get(ctx, req.(*GetUserPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserPasswordService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserPasswordServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.UserPasswordService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserPasswordServiceServer).Update(ctx, req.(*UpdateUserPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserPasswordService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserPasswordServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.UserPasswordService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserPasswordServiceServer).Delete(ctx, req.(*DeleteUserPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserPasswordService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserPasswordServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.UserPasswordService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserPasswordServiceServer).List(ctx, req.(*ListUserPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserPasswordService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateUserPasswordsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserPasswordServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/entpb.UserPasswordService/BatchCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserPasswordServiceServer).BatchCreate(ctx, req.(*BatchCreateUserPasswordsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserPasswordService_ServiceDesc is the grpc.ServiceDesc for UserPasswordService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserPasswordService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.UserPasswordService",
	HandlerType: (*UserPasswordServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _UserPasswordService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _UserPasswordService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _UserPasswordService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _UserPasswordService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _UserPasswordService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _UserPasswordService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}
